<!DOCTYPE html>
<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="styles.css">
</head>

<body>

	<div class="sidenav">
	  <p class="grouping"><b>Introduction</b></p>
	  <!--<a class="lesson" href="#">Why learn?</a>-->
	  <a class="lesson" href="#">Linux & Bash</a>
	  <!--<a class="lesson" href="#">C Langauage</a>
	  <a class="lesson" href="#">Assembly</a>
	  <a class="lesson" href="#">Debugging</a>
	  <a class="lesson" href="#">Stack & Heap</a>
	  <a class="lesson" href="#">Binary Protections</a>
	  <a class="lesson" href="#">Defeating Protections</a>
	  <a class="lesson" href="#">Linux Kernel</a>-->
	  <br>
	  <p class="grouping"><b>Reverse Engineering</b></p>
	  <a class="lesson" href="#">Compiling & Linking</a>
	  <!--<a class="lesson" href="#">Strings</a>
	  <a class="lesson" href="#">Decompiling Code</a>
	  <a class="lesson" href="#">Crackme Programs</a>-->
	  <br>
	  <p class="grouping"><b>Basic Exploits</b></p>
	  <a class="lesson" href="#">Pwntools</a>
	  <!--<a class="lesson" href="#">Shellcoding</a>
	  <a class="lesson" href="#">Sandboxing</a>
	  <a class="lesson" href="#">Interger Overflow</a>
	  <a class="lesson" href="#">Format Strings</a>-->
	  <br>
	  <p class="grouping"><b>Advanced Exploits</b></p>
	  <!--<a class="lesson" href="#">Advanced Concepts</a>
	  <a class="lesson" href="#">SIGROP Exploits</a>-->
	  <a class="lesson" href="off-by-one.html">Off-by-One</a>
	  <a class="lesson" href="/x32-abi.html">SECCOMP Bypass (x32 abi)</a>
	  <!--<a class="lesson" href="#">Heap Exploitation</a>-->
	  <br>
	  <p class="grouping"><b>Malware Analysis</b></p>
	  <a class="lesson" href="#">Data Recovery</a>
	  <a class="lesson" href="#">Malware Overview</a>
	</div>
	
	<div class="main">
		<h1>The C Language</h1>
		<h2>Introduction</h2>
		<p><b>C</b> is a low-level programming language created in 1972. Despite its age, C is still widely used today. In fact, many higher-level programming languages like Python, Java, and JavaScript are built on top of C.</p>

		<p>C is popular for many reasons. Foremost, C is available on pretty much any system. It's also portable, meaning if you write a piece of C code well, you can generally compile it on any other system and have it work the same way. C is also very fast; if you write a piece of C code and compile it, the speed at which it runs is much faster than a language like Python. Finally, C is a mature language. Significant changes to the C language standard are rare, unlike languages such as Python where new versions are released regularly--some of which aren't backwards compatible with older versions.</p>

		<p>C does have important drawbacks, though. It's a dangerous language for unexperienced programmers to use because there is no safety net--C will let you shoot yourself in the foot by always doing <em>exactly</em> what you tell it to do; nothing more, and nothing less.  This can cause unintended bugs which lead to exploitable software.</p>

		<p>Like Linux and Assembly, C can't be taught in a single page, so you should already be able to read C to some extent. That is going to be useful later as we start to look at and analyze C code for bugs and vulnerabilities.</p>
		
		<h2>Compiling & Running C Code</h2>
		<p>
		
		
		<pre><code>#include &lt;stdio.h&gt;

void func(char *str)
{
      char buf[256];
      int i;

      for (i=0; i &lt;= 256; i++)			// Bug: Loops 257 times
              buf[i] = str[i];

}

int main(int argc, char **argv)
{
      func(argv[1]);
}</code></pre>
		<br>
		<p>In the loop <code>for (i=0; i &lt;= 256; i++)</code> it is supposed to copy 256 bytes from <code>argv[1]</code>, but because of <code>i&lt;=256</code> it includes 256, meaning that it actually copies 257 bytes. So one byte after the buffer is overwritten. In this program (compiled with no stack canary), the saved RBP will be located right after the <code>buf[256]</code>, so it will overwrite the least significant byte of the saved RBP.</p>
		<br>
		
		<p>This can be fixed by only looping from 0 to 255 like:</p>
		
		<pre><code>for (i=0; i &lt; 256; i++)			// Bug: Loops 257 times
    buf[i] = str[i];</code></pre>
	
		<br>
		
		<h2>Exploitation</h2>
				
		<p>Depending on how the stack is laid out at that time, it may shift the value of the saved RBP to point into <code>buf[256]</code> which is controlled by the user. And with this, we can place shellcode on the stack and execute it (given the stack is executable). If the stack isn't exacutable, then we could use ret2libc.</p>

		<p>Although, we only have an example for an off-by-one vulnerability on the stack, the often appear on the heap as well. We will save this for the heap section though.</p>
		
	</div>
</body></html>